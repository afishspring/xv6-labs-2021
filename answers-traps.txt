1. a0-a7存放参数，例如13存放在a2中
2. 对函数调用做了内联处理。main直接计算出了结果并load
3. 0x628
4.30:	00000097          	auipc	ra,0x0
  34:	5f8080e7          	jalr	1528(ra) # 628 <printf>

  PS: auipc(Add Upper Immediate to PC): auipc rd imm
      jalr (jump and link register): jalr rd, offset(rs1)

  (1) auipc	ra,0x0
      ra = (0x0)31-12 + PC = 0x30
  (2) jalr	1528(ra) # 628 <printf>
        31        20 19      15 14  12 11    7 6       0
      -------------------------------------------------
      |    Imm     |    rs1   |funct3|  rd   | opcode |
      -------------------------------------------------
            12           5       3       5       7
      5f8080e7H = 5 f 8 0000 1000 0000 1110 0111
      通过验证 5f8H + 0x30 = 0x628
  
  第一步中ra保存的值为0x30，第二步加上偏移量5f8H后为0x628，即printf的地址。
  执行此代码后会跳转到0x628，然后PC+4存放到ra。
  因此ra值为0x38。

5.unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);

  57616 = 0xE110
  0x00646c72      -> 72 6c 64 00  -> r l d
  结果为: HE110 World
  大端存储需要将0x00646c72改为0x726c6400, 57616不需要变

6. 需要传入两个参数。y显示的值是当前a2寄存器中的值，具体内容取决于上次使用该寄存器的代码